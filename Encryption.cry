//Non linear layer 

Shift : {y ,z} (y == 3, z == 32)
 => [y][z] -> [y][z]
Shift column = [a] # [b] # [(column @ 2)]
  where  a = (column @ 0 <<< 24) : [32]
         b = (column @ 1 <<< 9) : [32]

ShiftCols : {x, y ,z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
ShiftCols matrix = transpose Shifted
  where Tmatrix = transpose matrix
        Shifted = map (\x -> Shift x) Tmatrix

TFunction : {y, z} (y == 3, z == 32)
 => [y][z] -> [y][z]
TFunction column = [x1] # [y1] # [z1]
  where x = (column @ 0) : [32]
        y = (column @ 1) : [32]
        z = (column @ 2) : [32]
        x1 = x ^ (z << 1) ^ (( y && z) << 2)
        y1 = y ^ x ^ ( (x || z) << 1)
        z1 = z ^ y ^ ((x && y) << 3)

TFunctionCols : {x, y, z} (x == 3,y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
TFunctionCols matrix = transpose output
  where Tmatrix = transpose matrix
        output = map (\x -> TFunction x) Tmatrix

SwapRows : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
SwapRows matrix = [Z] # [Y] # [X]
  where X = matrix @ 0
        Y = matrix @ 1
        Z = matrix @ 2

SPbox : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
SPbox matrix = Swapped
  where Shifted = ShiftCols matrix
        Value = TFunctionCols Shifted
        Swapped = SwapRows Value


//Linear layer

SmallSwap : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
SmallSwap matrice = transpose ([second] # [first] # [fourth] # [third])
  where transposed = transpose matrice
        first = (transposed @ 0) : [3][32]
        second = (transposed @ 1) : [3][32]
        third = (transposed @ 2) : [3][32]
        fourth = (transposed @ 3) : [3][32]

BigSwap : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
BigSwap matrice = transpose ([third] # [fourth] # [first] # [second])
  where transposed = transpose matrice
        first = (transposed @ 0) : [3][32]
        second = (transposed @ 1) : [3][32]
        third = (transposed @ 2) : [3][32]
        fourth = (transposed @ 3) : [3][32]


//Add Constant

AddConstant : {x, y, z} (x == 3, y == 4, z == 32) 
 => ([x][y][z], [z]) -> [x][y][z]
AddConstant (matrix, r) = [([S00] # (matrix @ 0) @@ [1..3])] # (matrix @@ [1,2])
  where S00 = (0x9e377900 ^ r ^ ((matrix @ 0) @ 0))

//Gimli Permutation

NextWord : {x, y, z} (x == 3, y == 4, z == 32)
 => ([x][y][z], [z]) -> [x][y][z]
NextWord (state, i) = output
  where output = if i % 4 == 0 
                 then AddConstant((SmallSwap (SPbox state)), i)
                 else if i % 4 == 2 
                      then BigSwap(SPbox state)
                      else SPbox state

GimliPermutation : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [x][y][z]
GimliPermutation state = output ! 0
  where output = [state] # [NextWord(x, i) | x <- output
                                           | i <- [24, 23 .. 1]
                           ]

//Absorb

Absorb : {x, y, z} (x == 3, y == 4, z == 32)
 => ([x][y][z], [y][z]) -> [x][y][z]
Absorb (state, m) = GimliPermutation([first] # state @@ [1, 2])
  where first = [x ^ y | x <- state @ 0 | y <- m]

//Squeeze

Squeeze : {x, y, z} (x == 3, y == 4, z == 32)
 => [x][y][z] -> [y][z]
Squeeze matrix = matrix @ 0

//////////////////////////////////////////////////////////////////////
// Tu zaczynaja sie funkcje uzywane do szyfrowania
//////////////////////////////////////////////////////////////////////

//Encryption

SetState : {x, y, z} (x == 3, y == 4, z == 32)
 => ([y][z], [2][y][z]) -> [x][y][z]
SetState (nonce, key) = GimliPermutation([nonce] # key)

//Process data

// ProcessAD : {x, y, z, n} (x == 3, y == 4, z == 32, fin n)
//  => ([x][y][z], [n][y][z]) -> [x][y][z]
// ProcessAD (state, data) = GimliPermutation( Absorb (output, data ! 0) )
//   where absorbed = map (\s -> Absorb(state, data @ s)) [0 .. n]
//         temp = absorbed ! 1
//         firstXored = [0x01000000 ^ ((temp @ 0) @ 0)] # (temp @ 0) @@ [1 .. 3]
//         lastXored = (temp @ 2) @@ [0 .. 2] # [0x00000001 ^ ((temp @ 2) @ 3)] 
//         output = [firstXored] # [temp @ 1] # [lastXored]
ProcessAD : {x, y, z, n} (x == 3, y == 4, z == 32, fin n)
 => ([x][y][z], [n][y][z]) -> [x][y][z]
ProcessAD (state, data) = GimliPermutation( Absorb (output, data ! 0) )
  where absorbed  = [state] # [Absorb(x, y) | y <- data
                                            | x <- absorbed
                              ]
        temp = absorbed ! 1
        firstXored = [0x01000000 ^ ((temp @ 0) @ 0)] # (temp @ 0) @@ [1 .. 3]
        lastXored = (temp @ 2) @@ [0 .. 2] # [0x00000001 ^ ((temp @ 2) @ 3)] 
        output = [firstXored] # [temp @ 1] # [lastXored]

//ProcessPlainText

ProcessPlaintext : {x, y, z, n} (x == 3, y == 4, z == 32, fin n, n >= 1)
 => ([x][y][z], [n][y][z]) -> ([n][y][z], [x][y][z])
ProcessPlaintext (state, plaintext) = (ciphertext, Absorb(lastState, plaintext ! 0))
  where states = [state] # [Absorb(x, y) | y <- plaintext
                                         | x <- states 
                           ]
        // states = [Absorb(state, x) | x <- plaintext]
        butLastStates = reverse(tail(reverse states))
        keys = [Squeeze state] # [Squeeze x | x <- butLastStates]
        ciphertext = [x ^ y | x <- keys | y <- plaintext]
        temp = states ! 1
        firstRow = [0x01000000 ^ (temp @ 0) @ 0 ] # (temp @ 0) @@ [1 .. 3]
        lastRow = (temp @ 2) @@ [0 .. 2] # [0x00000001 ^ (temp @ 2) @ 3]
        lastState = [firstRow] # [temp @ 1] # [lastRow]


Encryption : {x, y, z, n} (x == 3, y == 4, z == 32, fin n, n >= 1)
 => ([n][y][z], [n][y][z], [y][z], [2][y][z]) -> ([n][y][z], [y][z])
Encryption (M, AD, N, K) = (C, T)
  where output = ProcessPlaintext(ProcessAD(SetState(N, K), AD), M)
        C = output.0
        T = Squeeze(output.1)

//Decryption

Decryption : {x, y, z, n} (x == 3, y == 4, z == 32, fin n, n >= 1)
 => ([n][y][z], [n][y][z], [y][z], [2][y][z], [y][z]) -> ([n][y][z], Bit)
Decryption (C, AD, N, K, T) = (M, Tcheck)
  where output = Encryption(C, AD, N, K)
        M = output.0
        T' = output.1
        Tcheck = if T == T' then True
                            else False
